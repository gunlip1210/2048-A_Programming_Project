# 2048: A Programming Project
Implemented the 2048 game in C for programming practice.
![2048 순서도 2](https://github.com/user-attachments/assets/c051e0cb-7bb2-4a61-a226-e4ef3d4a6737)
![2048 순서도 3](https://github.com/user-attachments/assets/171e9fa3-225c-4eec-a791-16e764478319)


<전역변수>
int game_over : 게임이 종료되는 상황이면 1을 저장, 게임이 진행될 수 있는 상황이면 0을 저장.
int b[4][4] : 현재 진행 중인 게임의 4X4 판의 정보를 저장.

<int main(void)>
init() 사용자 정의 함수를 실행하여 전역변수 game_over과 b[4][4]를 0으로 초기화.
srand(time(NULL))함수를 실행하여 rand()함수의 seed값을 현재 시간으로 정함.
int tot = 0으로 초기화 후, make_two_or_four() 사용자 정의 함수의 반환값을 더해서 tot에 저장하는 과정을 두 번 실행함. 이 과정을 통해 2048 게임을 시작할 때 2개의 수를 임의의 위치에 저장하고, 이를 tot에 저장하므로써 tot와 b[4][4] 속의 합을 일치하게 만듦.
draw_board(tot,-1) 사용자 정의 함수를 실행하여 b[4][4]와 현재 점수를 화면에 출력함.
do while 반복문을 이용하여 사용자의 입력을 받아오고, 적절한 입력이 존재할 경우 판을 이동시킨 후 판을 출력하고 게임이 종료될 상황인지 체크한 후 게임이 종료될 상황이면 반복문을 종료함. 입력이 존재하지 않거나 입력이 적절하지 않다면 if문을 건너뛰고 다시 반복문의 처음으로 돌아가 사용자의 입력을 받음.
반복문이 종료될 조건은 게임이 끝난 경우이므로 game over! 출력 후 프로그램 종료.

<void init(void)>
game_over = 0과 for{b[i][j] = 0}반복문을 이용하여 전역변수 game_over와 b[4][4]의 값을 0으로 초기화 함.

<int make_two_or_four(void)>
int flag_zero = 0 : b[4][4]에 2 또는 4를 생성 가능한 경우 생성한 값을 저장하고, 생성이 불가능하다면 0을 저장함. 나중에 make_two_or_four 함수의 반환값을 정할 때 사용.
int a[4][4] = {0} : b[4][4]에 2 또는 4를 생성 가능한 위치는 1, 생성이 불가능한 위치는 0을 저장함.
int n = 4 : 2 또는 4 중 생성할 값을 저장함.
int row, col : 2 또는 4를 생성할 행과 열 정보를 저장.
for{if{a[i][j]=1; flag_zero = 1}}반복문 : b[4][4]의 원소의 값이 0이라면 그 위치에는 2 또는 4를 생성할 수 있으므로 a[4][4]의 원소의 값을 1로 바꾸고, b[4][4]의 원소의 값이 하나라도 0이면 2 또는 4가 생성 가능하므로 flag_zero의 값을 1로 바꿈.
flag_zero == 0이라면 2 또는 4를 생성할 수 없으므로 0을 반환하며 사용자 정의 함수 종료.
flag_zer0 ==1이라면 다음 단계에 따라 2 또는 4 중 생성할 값을 정하고 생성할 행과 열을 정함.
rand()함수가 생성하는 난수가 완전 무작위라고 가정을 한다면, 생성된 난수를 3으로 나누었을 때 나머지가 0, 1, 2가 나올 확률을 1/3으로 일정할 것이다. 따라서 2를 2/3 확률로, 4를 1/3 확률로 생성하기 위해 랜덤 생성된 난수를 3으로 나누었을 때 나머지가 1 또는 2라면 n의 값을 4에서 2로 바꾸어 저장함.
마찬가지로 행과 열 또한 무작위의 위치에 2 또는 4를 생성하기 위하여 rand() 함수가 새로 생성한 난수를 4로 나눈 나머지를 row에, rand() 함수를 한번 더 실행하여 새로 생성한 난수를 4로 나눈 나머지를  col에 저장하고, b[row][col]에 2 또는 4가 생성 가능한지 확인하기 위하여 a[row][col]이 1이면 while 반복문을 종료하고 0이라면 2 또는 4가 생성 불가능하므로 반복문을 계속 실행하도록 함.
b[row][col] = n : b[4][4]의 랜덤한 위치에 2 또는 4를 저장함.
생성한 값을 반환하며 사용자 정의 함수를 종료함.

<void draw_board(tot, command)>
기존 화면에 출력된 정보를 system(“clear”)을 이용하여 지움.
int sum = 0 : tot와 b[4][4]의 총합이 일치한지 확인하기 위하여 b[4][4]의 총합을 저장함.
for 반복문을 이용하여 sum에 b[4][4]의 원소의 값을 더하여 저장하고, b[4][4]의 원소의 값이 score보다 크다면 score에 b[i][j]를 저장하도록하여 b[4][4]의 원소 중 가장 큰 값이 score이 되도록함.
만약 tot와 sum 값이 다르다면 tot error를 출력하도록 함.
화면에 score와 b[4][4]를 출력하고, (txt 파일에 score, dir, b[4][4]를 출력하고) 사용자 정의 함수를 종료함.

<int GetCommand(void)>
getch() 함수를 통해 입력 받은 dwas를 사용하기 편리하도록 0123으로 바꾸어 반환함.
만약 dwas가 아닌 다른 값이 입력되었을 경우 –1을 반환하여 입력값이 적절하지 않음을 알려줌.

<int getch(void)>
사용자가 입력한 값을 반환함. 만약 입력한 값을 받는 과정에서 에러가 발생할 경우 –1을 반환함.

<int set_board(dir, b[4][4])>
int a[4][4] = b[4][4] : set_board() 실행 전후 b[4][4]의 변화가 있는지 확인하기 위해 처음 b[4][4]를 a[4][4]에 저장.
for{rotate(b)} : 사용자의 입력에 관계 없이 한 방향으로 이동시키기 위하여 dir 값 만큼 rotate() 사용자 정의 함수를 실행하여 배열을 회전시킴.
for{if{b[i][j+1] = b[i][j]}} : b[i][j]!=0 이고, b[i][j+1]==0일 경우 두 값을 바꿈으로써 숫자들을 우측 정렬 시킴.
if(b[i][0]==b[i][1] && b[i][2]==b[i][3]) : 첫 번째 두 번째 값이 같고, 세 번째 네 번째 값이 같을 경우 각각 두 개의 값을 더해서 저장함.
else{if(b[i][j]==b[i][j-1])} : 양옆으로 붙어있는 두 값이 같을 경우 각각을 더함.
for{if{b[i][j+1] = b[i][j]}} : 값들을 더한 후 값 사이에 0이 새로 생겼을 수 있으므로 우측 정렬 시키는 과정을 한번 더 진행함.
if{for(int i=4-dir; i>0; i--)} : 4-dir 횟수만큼 rotate() 사용자 정의 함수를 실행시킴으로써 편의를 위해 회전시켰던 b[4][4]를 원래대로 다시 돌림.
for{if(a[i][j] != b[i][j]){change = 1}} : a[4][4]와 b[4][4]를 비교하여 변화가 발생했는지 확인하고 변화가 없을 경우 사용자의 입력한 방향이 적절한 값이 아니라는 뜻이므로 0을 반환, 변화가 있을 경우 적절하게 이동되었으므로 1을 반환함.

<void rotate(b[4][4])>
int a[4][4] = {0} : b[4][4]를 시계방향으로 90도 회전시킨 배열을 임시로 저장하는 저장소.
for{a[i][j] = b[3-j][i]} : [3-j][i]를 [i][j]로 이동시키면 시계방향으로 90도 이동된 위치가 됨.
b[4][4] = a[4][4] : 임시로 a[4][4]에 저장되었던 90도 회전된 배열을 b에 저장하고 함수 종료.

<int is_game_over(void)>
int flag=1 : 게임 오버인지 아닌지 저장하는 변수. 게임이 진행될 수 있는 상황인지 여러 경우로 나누어서 확인해 볼 것이므로, 기본 값은 1로 저장함, 게임오버면 1, 게임이 진행 가능하다면 0의 값을 가짐.
for{if(b[i][j]==0)} : b[4][4]에 0이 하나라도 존재한다면 2 또는 4를 생성하고 게임이 진행 가능하므로 flag=0을 저장하고 0을 반환하며 함수 종료.
for{if(b[i][j]==b[i][j+1] || b[i][j]==b[i+1][j])} : 이웃한 두 값이 동일하다면 합치는 것이 가능하므로 flag=0을 저장하고 0을 반환하며 함수 종료. (예외는 다음 for,if문에서 처리)
for{if(b[3][i]==b[3][i+1] || b[i][3]==b[i+1][3])} : 위 for,if문에서 4번 행과 4번 열에 대해서 일부 예외가 발생하므로 그 예외를 처리하기함. 4번 행 또는 4번 열의 이웃한 두 값이 동일하다면 합치는 것이 가능하므로 flag=0을 저장하고 0을 반환하며 함수 종료.
if(flag) : 지금까지 함수가 종료되지 않고 실행되었다면 flag의 값은 1일 것이고, 이는 게임 오버 상황이므로 1을 반환하며 함수 종료.
